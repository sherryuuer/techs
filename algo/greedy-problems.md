## 贪心算法相关问题

---
### 概念解析

贪心算法（又称贪婪算法）是一种在对问题求解时，总是做出在当前看来是最好的选择，从而希望导致结果是最好或最优的算法。它是一种启发式算法，不保证一定能找到全局最优解，但通常情况下能找到较好的解。也就是说它是一种局部最优求解法。

贪心算法可以用于解决各种类型的优化问题，例如：

* 覆盖问题: 在给定一组集合的情况下，选择尽可能少的集合来覆盖所有元素。
* 分配问题: 将一组任务分配给一组机器，使得每台机器的负载最小化。
* 调度问题: 为一组任务安排一个顺序，使得完成所有任务所需的时间最短。
* 路径规划问题: 在给定一张图的情况下，找到从一个点到另一个点的最短路径。

这种算法简单易懂，易于实现。即使对于大规模问题，也能够在较短时间内找到解。然而它不保证一定能找到全局最优解。在某些情况下，可能找到非常差的解。

贪心算法是一种简单有效的启发式算法，可以用于解决各种类型的优化问题。尽管它不保证一定能找到全局最优解，但通常情况下能找到较好的解。在实际应用中，贪心算法经常与其他算法结合使用，以提高求解效率。

### 问题1:Jump Game I

给你一个非负整数数组 `nums`，你最初站在数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。以此判断你是否能够到达最后一个位置。以下是一个例子。

```
输入: nums = [2, 3, 1, 1, 4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达位置 1，然后再跳 3 步到达最后一个位置。
```

这个问题可以用贪心算法来解决。贪心算法的基本思想是：在解决问题时，总是做出在当前看来是最好的选择，希望最终能够得到一个全局最优解。如果使用暴力解法，是用回溯不断探索每次可以跳到的位置，如果无法触及最后，就回溯重新走，和遍历棋盘的意义一样，但是回溯的时间复杂度是指数级别的。

解题步骤：

- 从数组的最后一个位置开始往前遍历，设定目标位置 target 为数组的最后一个位置（即初始时为 n - 1）。
- 对于当前位置 i，判断是否能够跳到目标位置 target。如果能够跳到目标位置，则将目标位置更新为当前位置 i。
- 最后，判断目标位置是否为数组的第一个位置，如果是，则说明能够跳到最后一个位置，否则不能。


代码尝试：

```python
def jump_game(nums):
    target = len(nums) - 1
    for i in range(len(nums) - 2, -1, -1):
        if i + nums[i] >= target:
            target = i
    return target == 0
```

学习笔记：该算法的时间复杂度为 O(n)，其中 n 是数组的长度。该算法的空间复杂度为 O(1)，因为它只需要使用一个变量来记录当前能够到达的最后位置。

### 问题2:Boats to Save People

有一艘大船，你可以假设它就是泰坦尼克，需要对船上的人进行救援，救生船的数量无限制。如何用最少的船的数量，救所有的人。

已知 input 数据：people，是乘客的重量列表。limit是每艘船的重量上限。同时，每艘船空间上最多可以坐2个人。单个人不会超过船的载重限制。

题解思路：

- 将people列表从小到大排列。
- 初始化两个指针 left 和 right 分别指向列表的开始和结尾。
- 从两头开始遍历列表，检查最轻的人和最重的人的组合是否不超过船载重限制。
  - 若是则向中间移动两个指针一步，若否则只载重的人，将右指针向左移动一步。
  - 增加一艘船的数量。
- 当所有指针相遇，结束遍历，返回船的数量。

代码尝试：

```python
def rescue_boats(people, limit):
    people.sort()
    left, right = 0, len(people) - 1
    count = 0

    while left <= right:
        if people[left] + people[right] <= limit:
            left += 1
            right -= 1
        else:
            right -= 1
        count += 1

    return count
```

下面是给出的参考答案，简化了几行代码：

```python
def rescue_boats(people, limit):
    people.sort()
    left = 0
    right = len(people) - 1
    boats = 0  

    while left <= right:  
        if people[left] + people[right] <= limit:
            left += 1  
        right -= 1
        boats += 1 
    return boats
```

学习笔记：这道题只要想好并跟着解题思路写就很简单，贪心算法难的不是内部逻辑，而是人的解题思维，这么看来确实是一种符合直觉的解题方法。这道题的时间和空间复杂度集中在对列表的排序上，时间复杂度O(nlogn)，空间复杂度O(n)。
