## 概念和适用范围

概念上来说，它关注的是将树节点，按照高度进行合并。对一棵用edges表述的树来说，具体合并过程，相当于将每一个子节点都不断的向上合并，直到所有的节点都被压扁到他们共享一个父亲节点。这样以来如果有任何想要连接子节点，而不共享父节点的边，都是那个构成环的边，也就是冗余的边。

**适用问题：**

- 根据某种属性对元素进行分组，即将具有相同属性的元素划分到连通分量中。相当于将不同的节点，划分给不同的父节点。
- 需要将初始给定的不相交的集合两两合并，或判断两个元素是否属于同一集合。 
- 虽然问题的数据最适合用图的形式组织，但输入数据并非邻接表/矩阵的形式，需要进行数据转换和组织。

**现实世界问题：**

- 图像分割和区域合并: 通过将相邻相似颜色的像素合并成区域，来对数字图像进行分割。并查集可以跟踪每个像素所属的区域，并在区域合并时更新信息。
- 图像处理: 图像编辑应用中使用并查集来定位图像中不同的对象，实现选择区域、区分前景背景等功能。
- 网络连通性: 判断两个设备之间是否存在连通路径。
- 渗流: 确定液体通过滤波器的渗透阈值。使用NxN网格模拟滤波器，并查集连接相邻开放区域，若存在从顶部到底部的连通分量，则可渗流。
- 六角棋游戏: 通过连接同色棋子，判断哪个玩家获胜。

很好，很复杂。并查集本身就是一个高级的主题。在实际应用中联想，完全不如在算法问题中这么明晰，重要的是在实际中，不断的找到算法的影子。将理论和实践结合。

总的来说，并查集，和联通，冗余，分组问题相关，在遇到这些问题的时候，可以考虑运用。

### 问题1:Redundant Connection

该问题中，tree被定义为，无向无环图。你被给定了一个图，有 n 个节点，从 1 到 n，但是在这个图中，被加入了一条冗余的边，这条边被 1 到 n 中两个不同的端点连接。返回可以删除的边，以便生成的图是 n 节点树。如果有多个答案，则返回输入列表中最后出现的符合条件的答案。

比如，给定edges = [[1, 2],[1, 3],[2, 3]]， 输出[2, 3]

其实这是一个典型的，自己组装并查集的题，通过这道题正好可以切入并查集的基础结构。代码如下：

```python
class Solution(object):
    def findRedundantConnection(self, edges):
        """
        :type edges: List[List[int]]
        :rtype: List[int]
        """
        # 初始化父节点为该节点自己
        par = [i for i in range(len(edges) + 1)]
        # 将每个节点的高度设置为1
        rank = [1] * (len(edges) + 1)

        def find(n):
            """
            helper函数，是为了在下面的步骤中，用于找到节点的父节点
            while的部分表示，当自己的父节点不是自己的时候，就不断的将父节点的父节点，设置为该节点的父节点
            是一种压缩树高度的行为，最终找到父节点，即为该节点自己
            """
            p = par[n]
            while p != par[p]:
                par[p] = par[par[p]]
                p = par[p]
            return p

        def union(n1, n2):
            """
            union是用来进行合并的部分
            找到这两个节点的父节点，然后比较树的高度，将低的树合并到高的树上，并重新计算高度
            如果他们已经共享父节点了就不需要何必了
            return的，是否进行了合并
            """
            p1, p2 = find(n1), find(n2)

            if p1 == p2:
                return False
            
            if rank[p1] > rank[p2]:
                par[p2] = p1
                rank[p1] += rank[p2]
            else:
                par[p1] = p2
                rank[p2] += p1
            return True

        # 通过union返回值判断两个节点是否已经有同样的父节点
        # 如果有的话说明再连接就冗余了，返回该节点即可
        for n1, n2 in edges:
            if not union(n1, n2):
                return [n1, n2]
```

笔记：这是一道逻辑非常清晰的题，不再赘述。时间复杂度和空间复杂度都是O(n)。

这是因为在进行find和union的时候，它的时间复杂度都是阿克曼反函数大小。

时间复杂度O(α(n))中的α(n)是**阿克曼反函数(Ackermann inverse function)**的渐进记号表示。

阿克曼函数是一个数论函数,增长非常快,被用来定义计算复杂性理论中所需的差值级。α(n)是阿克曼函数的反函数,它是一种极其缓慢增长的函数。

具体来说:

- α(n)是一个非常缓慢增长的函数,它的实际值非常小,在实际应用中很少大于4。
- 对任何可以用现有计算机资源精力计算的n值,α(n)的值都不超过5。
- 任何实际运行的合理算法的时间复杂度都不会比α(n)更慢。

因此,O(α(n))被认为是计算复杂性理论中的一个很好的渐进记号,用来表示一个非常优秀、高效的算法,它的运行时间基本上可以认为是一个很小的常数。并查集的时间复杂度就是这个量级。

总之,O(α(n))反映了一种极其高效、接近最优的算法时间复杂度,实际应用意义重大。
