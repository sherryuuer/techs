## 网络基础知识（构架，应用层，HTTP）

---
东西有点多，分为几个篇章来学习。

### 网络的本质是什么，什么是互联网

我们深处网络之中，以至于太熟悉了而忽视了它到底是什么，就像我们忽视了最好喝的水和最珍贵的空气，反而去追求了更低级的乐趣和看似优越的东西。稀松平常，最容易得到的东西，才是滋养我们的东西。说多了，言归正传。

网络在不同的领域有不同的含义，但在计算机科学和通信领域中，网络通常指的是多个节点（计算机、设备或者其他终端）通过连接和通信协议相互之间进行数据交换和通信的结构。这种结构可以是物理上的连接，也可以是逻辑上的连接，通常以图形的形式来表示，其中节点表示网络中的终端，边表示节点之间的连接或通信链路。

网络的本质可以概括为以下几个方面：

1. **连接性**：网络的本质是连接多个节点，使它们能够相互之间进行通信和数据交换。这种连接性可以是物理上的连接，比如通过电缆、光纤等物理媒介连接，也可以是逻辑上的连接，比如通过路由器、交换机等设备进行数据转发。

2. **通信协议**：网络中的节点之间进行通信需要遵循一定的规则和约定，这些规则和约定通常被称为通信协议。通信协议定义了数据传输的格式、数据交换的方式、错误处理机制等，确保网络中的数据能够正确、可靠地传输和接收。

3. **数据交换**：网络的主要目的是实现数据的交换和共享。通过网络，用户可以将数据从一个节点发送到另一个节点，实现信息的传递和共享。数据交换可以是点对点的，也可以是多对多的，可以是实时的，也可以是异步的。

4. **信息传递**：网络提供了一种高效、便捷的信息传递方式。通过网络，用户可以随时随地与他人进行沟通和交流，分享信息和资源，获取所需的信息和服务。

### 网络的分层构架和协议栈

当我们谈论网络架构时，可以将其比作发送信件的过程来解释。我觉得这种比喻让我更容易理解。

我们有发送者和接收者。发送者是指发送数据或信息的源头，而接收者则是目标，他们将接收发送者传输的信息。我们都以为自己和对方是直接沟通的，但是下面经历了邮筒，邮箱，邮局，快递员等，还有大型的货运车站和机场，这些在网络的世界也同样存在，正是因为网络看起来各种分层的复杂性，才保证了网络的秩序。如果我们每个人都直接和对方通信，世界可能会很乱网络可能极其拥堵。个人信息四处横流。

在邮寄信件中，信封是承载信件的外部容器。地址则是确定信件传递目的地的关键信息。在网络中，数据包就像邮件一样，有一个外部容器和目的地地址。这个地址可以是IP地址或URL。

邮局和邮递员负责处理和传递信件。他们根据地址将信件从发送者传递到接收者。在网络中，路由器和交换机扮演了类似的角色。它们根据数据包的目的地地址将数据从一个地方传输到另一个地方。

传输协议，就是我们送信，信息交换的共同规定，在邮寄信件中，邮递员需要遵循一定的规则和程序来确保信件安全地传递。在网络中，有许多传输协议，如TCP/IP，它们规定了数据如何被分割、传输和重组，以确保数据安全和可靠地到达目的地。

邮件可以通过不同的邮寄服务发送，例如普通邮件、快递服务等。在网络中，也有多种服务提供商和网络运营商，用户可以选择不同的服务来满足其需求。

这整个邮寄信件的过程，可以帮助理解网络架构中的基本概念和运作原理。发送者、接收者、地址、传输过程、网络设备等概念在两者之间有着惊人的相似性，帮助我们更好地理解网络世界的运作。

**网络的分层构架和协议栈**是一种组织和管理网络通信的方式，它将网络通信划分为多个层次，并在每个层次上定义一组特定功能的协议集合。这种分层结构有助于提高网络的可管理性、可靠性和可扩展性，同时也使不同厂商和组织可以独立开发和实现不同层次的协议，从而促进了网络的发展和标准化。

网络的分层构架通常由多个层次组成，每个层次负责不同的功能，各层之间通过接口进行交互和通信。常见的网络分层构架包括 OSI（Open Systems Interconnection）参考模型和 TCP/IP（Transmission Control Protocol/Internet Protocol）协议栈。

OSI参考模型将网络通信划分为七个层次，从物理层到应用层依次为：

- 物理层（Physical Layer）：负责传输比特流，管理物理介质的传输特性。硬件，电缆，线路，机械。
- 数据链路层（Data Link Layer）：负责在相邻节点之间传输数据帧，进行数据的*流量控制*和*错误检测和纠正*。
- 网络层（Network Layer）：负责实现*数据包*在网络中的路由和转发，以及逻辑地址的分配和映射。这一层有*路由协议*和*负载均衡*。
- 传输层（Transport Layer）：负责实现端到端的可靠数据传输和流量控制，提供*端口号和数据段的分段和重组*。
- 会话层（Session Layer）：负责建立、*管理和终止会话连接*，提供会话标识和同步机制。
- 表示层（Presentation Layer）：负责数据的*编码*、解码和格式转换，还有*加密*，确保不同系统之间的数据*格式兼容*。也就是以应用层易于理解和显示的方式呈现数据。
- 应用层（Application Layer）：负责为用户提供各种*网络应用和服务*，如文件传输、电子邮件、网页浏览等。这个层大部分是我们最多接触的层，各种软件都在这里，幽默的来说，有一个第8层，它是一个由最终用户组成的伪层！许多IT工程师都幽默地说，用户的问题“第8层问题”。

一个便于记忆的方法是：请不要扔掉香肠披萨，从下到上：Please do not throw sausage pizza away.

每个层级负责特定的功能，而且每个层级都认为它在与同一层级的设备进行通信。然而，在实际的通信中，数据传输需要经过各个层级的处理，从而实现端到端的通信。每一层级对上一层级提供服务，并使用下一层级的服务，因此数据在从上层传输到底层的过程中会逐渐被抽象化，从而实现了网络通信的可靠性、灵活性和可扩展性。在最底层，通过物理层的时候，我们的信息就只是二进制的数字了，而应用层则是丰富多彩的世界。

**网络世界和机器学习张量世界一样，一切都是数字。**

TCP/IP协议栈是互联网使用的网络分层构架，它将网络通信划分为四个层次，从网络接口层到应用层依次为：

- 网络接口层（Network Interface Layer）：负责将数据帧转换为比特流，并管理物理介质的传输。
- 网际层（Internet Layer）：负责实现数据包的路由和转发，提供 IP 协议进行数据包的封装和解封。
- 传输层（Transport Layer）：负责提供端到端的可靠数据传输，使用 TCP 或 UDP 协议进行数据的分段、重组和流量控制。
- 应用层（Application Layer）：负责为用户提供各种网络应用和服务，如 HTTP、FTP、SMTP 等。

由于底层负责从上层收集消息并传递到目的地，并移交发往上层的消息，因此它为应用层服务。此外，应用层进行抽象，因此不关心下面各层的任何实现细节。

下面的部分细说这个重要协议。

### 网络构架的发展

网络架构的发展经历了多个阶段，从早期的简单网络到今天的复杂、高度互联的网络。说什么早期，整个算下来，其实就在非常短的时间内，网路就进化到了这样的规模，只是因我们很多人刚生下来就已经有网络，所以觉得理所当然，但是用更远的眼光去看，其实在很短的时间，世界就发生了翻天覆地的变化。技术爆炸太可怕了。

- **ARPANET（美国国防部高级研究计划局网）**：1969年，ARPANET建立了最早的分散式网络，连接了四个节点。它是互联网的前身，旨在为军事和学术界提供通信。
- **TCP/IP协议的发展**：1970年代后期至1980年代初期，TCP/IP协议被开发出来，成为互联网的核心协议。它提供了一种标准的数据传输方式，使不同类型的计算机能够相互通信。
- **商用互联网的出现**：1990年代，互联网开始向公众开放，商业化程度增加。大量的企业和个人开始接入互联网，促进了网络的快速扩张和发展。
- **World Wide Web的发展**：1990年，Tim Berners-Lee发明了World Wide Web，并创建了第一个网页浏览器和服务器。Web的出现使得互联网更易于使用和理解，推动了网络的普及和快速增长。
- **移动互联网的兴起**：2000年代后期至2010年代，随着智能手机和移动设备的普及，移动互联网成为了互联网的重要组成部分。人们可以随时随地通过移动设备访问互联网，这推动了云计算、移动应用和移动支付等技术的发展。
- **云计算的发展**：2000年代后期至2010年代，云计算技术迅速发展，使得用户可以通过互联网访问各种计算资源和服务，而无需购买和维护自己的硬件和软件设施。
- **大数据技术的兴起**：2010年代以后，随着数据量的不断增加，大数据技术成为了网络架构中的重要组成部分。通过大数据分析，人们可以从海量数据中获取有价值的信息和洞见，推动了许多行业的发展和创新。
- **物联网的发展**：2010年代以后，物联网技术迅速发展，将各种设备和物品连接到互联网，形成了一个庞大的网络。物联网的出现推动了智能家居、智慧城市和工业4.0等领域的发展。
- **边缘计算的兴起**：随着物联网设备数量的增加和数据量的增长，边缘计算技术逐渐崭露头角。边缘计算将计算和数据存储放置在靠近数据源的位置，以降低延迟并减少对中心数据中心的依赖。

### TCP/IP协议栈

OSI 模型定义了七个层级，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层，它是一个参考的框架，更加的抽象，但是很少有设备按照这个框架实现。TCP/IP 模型则将网络通信划分为四个层级，分别是网络接口层（或称链路层）、网络层、传输层和应用层。这个模型更加简洁，适用于实际的互联网协议栈。

TCP/IP 模型则直接对应了一系列具体的协议，如以太网、IP、TCP 和 HTTP 等，这些协议构成了现代互联网的基础。

- 网络接口层（或称链路层）：负责物理介质上的数据传输，如以太网、Wi-Fi 等。
- 网络层：处理在不同网络之间的数据包传输，主要通过 IP 地址来进行路由选择，常见的协议有 IP、ICMP、ARP 等。
- 传输层：提供端到端的数据传输服务，确保数据的可靠传输，常见的协议有 TCP 和 UDP。
- 应用层：包含了各种应用程序和服务，如 HTTP、FTP、SMTP 等，用户通过这些应用与网络进行交互。

这些东西很重要，下面一个一个展开。

### 应用层 application layer

在网络架构中，应用层是网络协议栈中的最顶层，它在我们的终端里。负责处理应用程序之间的通信和数据交换。应用层包括了各种各样的协议和服务，用于支持不同类型的应用程序，例如电子邮件、网页浏览、文件传输等。在应用层，数据被格式化和解析成适合特定应用程序使用的格式，然后通过下层协议（传输层和网络层）进行传输。常见的应用层协议包括HTTP、FTP、SMTP、POP3、IMAP、DNS等。应用层的功能包括数据编码、加密、压缩、会话管理、用户认证等。

我们平常说的，**应用开发**通常指的是在应用层开发软件。这涵盖了开发各种类型的应用程序，包括桌面应用程序、移动应用程序、Web 应用程序等。在应用层开发软件时，开发人员利用应用层协议和服务来实现特定的功能和业务逻辑，以满足用户的需求。因此，应用开发是在网络协议栈的应用层进行的软件开发活动。

软件工程师这种最热门的职业，就是干开发应用，大多数人认为用户应用程序才是互联网的真正目的。如果不存在有用的应用程序，互联网就不会是今天的样子。

以下是关于这一层的很多重要概念。

**应用程序构架**：

- 客户端client-服务器server。比如谷歌浏览器，背后有无数servers，就像是二十四小时便利店，随时你都可以access到google网页进行查询。
- Peer-to-Peer Architecture（P2P）端到端构架，是一对一的，这种方式比较简单。
- 混合型 Hybrid，也就是上面两种的混合，比如你的个人信息在服务网站上，然后别人通过服务网站告诉你你有客户了，然后你就可以进行点对点通信。

**程序Program vs. 进程Process vs. 线程Thread**：简单来说，程序就是你的一个执行文件，比如你的微软word软件。进程是一个程序的实例，比如你打开了多个word窗口，他们每个都是进程。线程是一种轻量级的进程，比如你在word中进行了一个save的操作。他们是从上到下包含的关系。

**套接字 Sockets**：套接字与程序密切相关，是程序和计算机网络的接口。在网络编程中，程序可以使用套接字来建立连接、发送和接收数据以及错误对应，并处理与网络通信相关的各种任务。开发者可以使用编程语言提供的套接字库（如Python中的socket模块）来创建套接字，并在程序中实现网络通信功能。它是一种软件接口，和硬件无关。

**寻址 Addressing**：如何在浩如烟海的网络中找到你的消息目的地，这里就是**IPs and Ports**登场的地方了。如果将你的邮件寄信的比喻的目的地比做一栋大楼，那么IP就是大楼的地址，而Ports就是大楼中的房间号码。每个房间都是一个可以运行的应用程序。比如Http和Https等。

**临时端口 Ephemeral Ports**：是计算机网络中用于临时通信的端口。在通信中，临时端口通常由客户端动态分配，并且在通信结束后会被释放，以便其他客户端可以使用。它们通常用于客户端向服务器发起连接时临时使用，而不是固定的端口号。临时端口号范围通常在特定范围内，例如在Unix/Linux系统中，临时端口号范围为1024到65535，而在Windows系统中通常为49152到65535。使用临时端口的好处是可以避免端口冲突和提高系统的安全性。由于临时端口是动态分配的，所以它们不会长期占用系统资源，也不会暴露系统的固定端口给外部网络。这样可以有效地减少恶意攻击和网络嗅探的风险。再次进行比喻，这个临时端口，就像是大楼中的临时房间，可以做各种事，你用房间要提前申请，用完了还要把房间归置好了还回去钥匙。

### HTTP

**协议 HTTP**：全名超文本传输协议，反正网页这个东西就是各种文件作为对象而已，URL其实就是服务器上的文件的地址，那一串网址包括的是：协议，主机名称，文件位置，和参数。仅此而已。HTTP是刚刚说的构架中的客户端-服务器构架中的协议。它是一种无状态协议，这意味着，你对服务器发了很多次请求，服务端也不知道是你发的。

在网络通信中，HTTP（Hypertext Transfer Protocol）是一种应用层协议，用于在客户端和服务器之间传输超文本数据。HTTP是建立在传输层协议 UDP（User Datagram Protocol）和 TCP（Transmission Control Protocol）之上的。

TCP 和 UDP 是**传输层协议**，它们负责在网络中传输数据。TCP 提供了可靠的数据传输服务，它确保消息始终被传递，并且以发送的顺序进行传递。UDP 则不保证消息的传递，这意味着有些消息可能会丢失，从而导致接收方无法接收到这些消息。

HTTP 使用 TCP 作为其底层传输协议，这意味着消息在传输过程中是被保证被传递的，并且按照发送的顺序进行传递。这使得应用程序无需构建额外的可靠性机制，因为 TCP 已经为其提供了这种可靠性。

TCP 是面向连接的，这意味着在与服务器进行通信之前，客户端必须通过一系列的起始消息来建立连接。一旦连接建立成功，客户端和服务器之间就会交换消息，直到连接被正式关闭为止。在关闭连接之前，会发送一些结束消息来进行通知。

因此，HTTP 之所以依赖于 TCP，是因为 TCP 提供了可靠的数据传输服务，确保了 HTTP 消息的可靠性和顺序性。这种对其他层的依赖是分层架构的一个关键优势之一，它使得应用层能够专注于提供更高层次的功能，而无需处理底层细节。

**HTTP连接类型**可以分为持久连接（Persistent Connection）和非持久连接（Non-Persistent Connection）两种。

1. 持久连接（Persistent Connection）：
持久连接允许客户端和服务器在单个 TCP 连接上发送和接收多个 HTTP 请求和响应。在持久连接中，客户端在发送完一个请求后保持连接打开状态，以便可以在同一连接上发送后续的请求，而无需重新建立连接。这种方式可以减少连接建立和关闭的开销，提高通信效率，并且可以避免因频繁建立连接而造成的资源浪费。

2. 非持久连接（Non-Persistent Connection）：
非持久连接是指在每次 HTTP 请求和响应之间都会建立一个新的 TCP 连接。在非持久连接中，每个 HTTP 请求都会创建一个新的连接，请求完成后连接立即关闭。这种方式导致了频繁的连接建立和关闭操作，增加了通信的开销和延迟，降低了通信效率。

持久连接通常用于现代的 Web 应用中，它可以提高 Web 页面的加载速度和用户体验。相比之下，非持久连接由于连接建立和关闭的开销较大，通常在一些特定场景下使用，如对于单个页面的简单请求和响应，或者对于一次性的短期通信。

**Http request messages**：

HTTP 请求消息是客户端（例如浏览器）发送给服务器的数据包，用于请求特定资源或执行特定操作。它由两个主要部分组成：请求行、消息头部和消息体。

假设我们有一个网页，地址是 `https://www.example.com/index.html`，现在浏览器需要获取这个网页，它会发送一个 HTTP 请求消息给服务器。

这个请求消息通常包括以下内容：

- 请求行：请求行包含请求的方法、URL 和 HTTP 版本。在这个例子中，请求行可能是这样的：
```
GET /index.html HTTP/1.1
```
这表示浏览器使用 GET 方法请求 `/index.html` 这个资源，并且使用 HTTP/1.1 版本的协议。

- 消息头部：消息头部包含一些关于请求的元信息，比如客户端的信息、期望的响应格式、请求的范围等。例如：
```
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
```
这些头部信息告诉服务器请求的主机名、客户端的类型和支持的内容格式等。

- 消息体**：对于 GET 请求来说，通常不包含消息体。但对于一些 POST 请求等，消息体中会包含客户端发送的数据。

通过自己的浏览器就可以进行查看以上的内部请求代码，浏览器右边inspect，选择network选项卡后随便选择一个cell就可以看到上面类似的请求内容了。

**Http response messages**：

HTTP 响应消息是服务器向客户端（例如浏览器）发送的数据包，用于响应客户端的请求。它也由三个主要部分组成：状态行、消息头部和消息体。

继续使用之前的示例来说明：

假设客户端发送了一个 GET 请求来获取 `https://www.example.com/index.html` 这个网页，服务器会返回一个 HTTP 响应消息。

这个响应消息通常包括以下内容：

- 状态行：状态行包含响应的 HTTP 版本、状态码和状态消息。例如：
```
HTTP/1.1 200 OK
```
这表示服务器使用 HTTP/1.1 版本的协议，响应状态码为 200，状态消息为 OK，表示请求成功。

- 消息头部：消息头部包含一些关于响应的元信息，比如服务器的信息、响应的内容类型、内容长度等。例如：
```
Content-Type: text/html; charset=utf-8
Content-Length: 1234
```
这些头部信息告诉客户端响应的内容类型是 HTML，并且内容长度为 1234 字节。

- 消息体：消息体包含了服务器发送给客户端的实际内容。在这个例子中，消息体可能是网页的 HTML 内容。

HTTP 响应状态码与我们调用 API 时接收到的响应状态码是相似的，都是用来表示请求处理的结果，只不过 HTTP 协议中规定了一组标准的状态码，而 API 接口的状态码可能由具体的应用程序或服务定义。

**http响应和API响应**：

HTTP 响应和 API 响应在概念上是相似的，都是指服务器对客户端请求的处理结果。然而，它们之间存在一些区别，主要体现在以下几个方面：

1. 协议和用途：
   - HTTP 响应是基于 HTTP 协议的，用于在 Web 浏览器和 Web 服务器之间传输数据，以呈现网页或执行其他 Web 相关操作。
   - API 响应是指 API 服务端对客户端请求的响应，用于在不同系统之间进行数据交互，通常用于实现应用程序之间的通信或对外提供服务接口。

2. 规范和定制：
   - HTTP 响应遵循 HTTP 协议的规范，状态码和头部信息都遵循一定的标准。
   - API 响应通常由具体的应用程序或服务定义，可以根据需求定制响应内容的格式、结构和状态码。

3. 数据内容：
   - HTTP 响应中的数据内容通常是 Web 页面的 HTML、CSS、JavaScript 等内容，用于在浏览器上渲染页面。
   - API 响应中的数据内容通常是结构化的数据，如 JSON 或 XML 格式，用于在应用程序中进行数据处理和交互。

4. 用途和场景：
   - HTTP 响应主要用于 Web 开发中，用于处理网页的展示和交互。
   - API 响应主要用于软件开发中，用于实现系统之间的数据交换和服务调用。

虽然 HTTP 响应和 API 响应在某些方面有所重叠，但它们的应用场景和特点不完全相同，需要根据具体的需求和情况选择合适的响应方式。

**curl命令**：

curl是一个命令行工具和库，用于传输数据，支持多种协议，包括HTTP、HTTPS、FTP等。它可以通过命令行发送网络请求并接收响应，是一个非常强大和灵活的工具，常用于调试和测试网络服务。可以使用curl来查看响应内容，是因为curl支持HTTP协议，可以向服务器发送HTTP请求，并获取服务器返回的响应数据。通过在命令行中输入curl命令，并指定要请求的URL，curl会发送请求并将服务器返回的响应内容显示在命令行中，包括响应头和响应体等信息。

例如，可以使用以下命令来发送一个HTTP GET请求，并查看服务器返回的响应内容：
```
curl https://example.com
```
这将向对应网址发送一个GET请求，并在命令行中显示服务器返回的响应内容。

**Cookies**：

Cookies是存储在用户计算机上的小型文本文件，用于跟踪用户在网站上的活动和状态信息。它们是由网站发送到用户浏览器中的，并由浏览器存储和管理。当用户访问网站时，浏览器会将与该网站相关的Cookie信息发送回服务器，以便服务器能够识别用户并提供个性化的体验。

工作原理：
- 服务器在HTTP响应中发送一个Set-Cookie标头，其中包含了要设置的Cookie的信息，比如名称、值、过期时间、域名等。
- 浏览器收到响应后，将Cookie保存在本地存储中，通常是在一个文本文件中。
- 在之后的每次HTTP请求中，浏览器都会将与请求相关的Cookie信息发送给服务器，以便服务器能够识别用户。

可能的风险：
- 隐私泄露：Cookies可以用于跟踪用户的活动和个人偏好，如果被恶意利用，可能会导致用户隐私泄露。
- 安全漏洞：如果Cookie被篡改或窃取，可能会导致安全漏洞，使攻击者能够获取用户的敏感信息。
- 跨站请求伪造（CSRF）：攻击者可以利用Cookie来伪造用户的身份，并执行未经授权的操作。

第三方Cookies：

第三方Cookies是由不同于用户当前正在访问的网站的域名下的服务器设置的Cookies。它们通常用于广告跟踪和分析，允许广告商和分析服务提供商跟踪用户在不同网站上的活动。第三方Cookies经常引发隐私和安全问题，因为它们可以被用来跟踪用户的浏览历史和行为习惯，而用户可能对此并不知情或同意。

