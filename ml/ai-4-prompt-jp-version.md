## LLM（large-language Model）を簡単に説明する挑戦および開発者へのアドバイス

### 説明挑戦の理由

自分が学習した、機械学習と深層学習に関する様々な知識のうち、複雑な原理などを除き、わかりやすい部分を抽出して書いたこの文章では、現在大変人気の高いLLMをわかりやすく、説明することに挑戦したいと思います。

説明する目的は、よりハイレベルで、人に理解してもらえること、特に、ソフトウェアエンジニアやシステムエンジニアが、システムアーキテクチャを構築する際、自分が面しているLLMが何かを、より明確に把握できるようにできることです。

LLMは、現在称賛されているほど人気があるだけでなく、実際には重要な技術的節目であり、ロジカルな言語を生成できるのが、科学者でさえ説明できず、現状は、単に「創発現象」と結論付けられています。

科学者によると、それは世界の全体人類の知識の鏡であり、縮図であり、初歩的な反映であり、それとの対話は実際には全世界の鏡との対話だと言われています。

それが何かを理解し、その可能性を掘り下げれば、自分の仕事と生活に良い影響を与えると良いなあと思います。

特にソフトウェアやシステム開発者は、将来的にAIシステムなどの関連するアーキテクチャの開発に携わる可能性が高いため、比較的高いレベルでそれを理解する必要があると考えています。

(説明では複雑な原理の説明は省き、エンジニアリングの適用の観点からLLMの構造のみを説明しています。複雑な原理に興味のある方は、TensorflowやPytorchなどのライブラリやカリキュラム、コースなどを自分で探索することをお勧めします。)

### 初歩的説明

まず範疇について説明します。機械学習には深層学習が含まれ、深層学習には自然言語処理が含まれ、自然言語処理のアルゴリズムによって、LLMが生成されます。

これらはすべて、**アルゴリズム　+　データ**からモデルを生成するプロセスを経ています。

モデルとは何でしょうか。プログラミング言語を理解している人にとって、モデルは**インスタンスメソッド**と考えることができます。あるいは、より簡単に言えば、**関数**そのものです。

システムアーキテクチャのエンジニアやソフトウェア開発者の役割は、APIを呼び出してこの関数を実行し、システム内のタスクを達成することだけです。

モデルがどのように生成されたかは、データサイエンティストの仕事です。この部分を気にする必要はなく、AI時代においてエンジニアがその進歩に遅れることはありません。

### 具体な例えを用いて説明

モデルの実行には2つのファイルが含まれます。1つは parameters (どのような読み取り可能なファイルでも)、もう1つは run.py (実際にはMetaの llama-2-70b モデルをコンピューターにインストールすると、設定ファイルを開いたときに parameters と run.c という2つのファイルが表示されますが、ここではPythonコードを使って例えます)です。

LLMを実行するときは、run.pyファイルを実行しているのと同じことです。

```python
from parameters import param

def run(input):
    result = 0
    for x in param:
        input *= x
        result += input
    return result
```

このようなコーディングは少し愚かしいかもしれませんが、一言で言えば、parametersファイルには行列の集まりが含まれているだけです。これらの行列は、変換の役割を果たし、ユーザーの入力値と掛け算や足し算の計算を行い、最終的に結果を出力します。

複雑な数学の部分は省略していますが、直感的な表現としては間違いありません。

(補足すると、このコードのロジックは、Pytorchの前向き伝播、つまり推論時の簡易的なクラスメソッドの表現にあたり、推論とはモデルで予測を行うプロセスのことです。非常にシンプルです。)

以上がモデルの説明になります。一言で言えば、ユーザーの入力に基づいて数学的な計算を行い、結果をユーザーに返すプロセスであり、それ以外の何物でもありません。

### LLMの特別な点は何ですか？

使うには、特別なところは関数とは違いありません。コンピュータの世界では、モデルをトレーニングするには、まずすべての言語をトークン、さらにはベクトルへと処理することです。結果的に、言語もコンピュータの世界では数字になるため、LLMモデルと通常の機械学習モデルとは何の違いもありません。アルゴリズムの複雑さが違うだけです。

では、なぜTransformerというアルゴリズムが最も人気があり、複雑で高度に見えるのか？

単純に言ってしまえば、それは人間の言語における多くの不確かな言語の関係問題を解決しているようです。しかし、率直に言うと、この問題解決方法は、またもや行列の乗算の束であり、完全に線形代数です。本当に解決はしてないだろうと思います。LLMは人言の言葉は理解してないからです。

（例としては世界中で有名は俳優のAさんの母さんはBですとメッセージが結構ありますが、LLMに聞いたらすぐAのお母さんがBと答えできますが、もしLLMに”Bさんの息子は誰”と聞いたら、”そのような情報がありません”と返します。）

従来の機械学習のモデルとの違いをしいていうと、前回の入力内容が次回の出力の素材として使用できることです。つまり、入力内容がより詳しくであれば、モデルの出力効果がより良くなります。LangChain、Historyに会話を蓄積することができ、それらも次の生成に役たつとのことです。ではこれにより、LLMが非常に知的に見えますが、実際には、判断と計算に使用される数字が増えるため、より関連性の高いコンテンツを出力できるだけです。

### モデルのバージョンには多くの種類がありますが、その違いは何でしょうか？

パラメータが多いほど、つまり、先ほど言及した parameters ファイル内のパラメータが多いほど、モデルの計算量が増え、結果がより良くなります。これが GPT3.5 と GPT4 の違いです。

GPT3.5 はトレーニングが完了した後、そのパラメータが提供され、その後、GPT3.5 の上でパラメータを追加してトレーニングを継続（ファインチューニング）することで、より良いモデルを得ることができます。

モデルがより高度であれば、処理できるタスクも多くなります。たとえば、言語を入力して画像を出力したり、画像を入力してテキストを出力したり、テキストを入力して音声を出力したりすることができます。これらの異なるタイプの変換は、人々が言う「マルチモーダル」です。

マルチモーダルの意味は、モデルが人間のような能力を持つことを望んでいることです。つまり、見ることができ、話すことができ、聞くことができ、描くことができる能力です。

### ChatGPTの概念解説

GPTモデルとChatGPTは同じ概念ではありません。ChatGPTは、単にGPTモデルを基にしたウェブアプリケーションです。

GPTは、Generative Pre-trained Transformerの略です。

以下にChatGPTを解説します：

**Generative**は、出力を生成することを意味します。対照的に、エンコードはモデルのトレーニングを通じて、巨大なウェブテキストをparameters（先ほど比喩したファイル）に変換することを意味します。

**Pre-trained**は、事前にトレーニングされたことを意味し、これはベースモデルと呼ばれます。この段階では会話はできません。それは賢いが無口なようなものであり、質問したら奇妙な内容を出力します。モデルに対してAPIコールした後、何も指導してないものに近しいです。

**Transformer**は、ほぼすべての大規模言語モデルの基本アルゴリズムです。Googleが開発しました。

**Chat**は、ベースモデルを元に、特定の対話タスクに対してさらなるトレーニングと最適化が行われたことを意味します。このプロセスはファインチューニングと呼ばれ、その結果がアシスタントモデルです。

有料ユーザーは、OpenAIのバックエンドで独自のファインチューニングを行い、独自のアシスタントボットを作成できます。例えば、翻訳専用のボットや、コーディング専用のボットなどがあります。ChatGPTは単にチャット用のアシスタントです。

ファインチューニングとは何か？それはモデルをガイドし、再び軽微なトレーニングを行うことです。たとえば、ほとんどのパラメータを固定し、出力部分のみをガイドして規制し、少数のパラメータをトレーニングし、調整された新しいモデルを生成するプロセスです。

また、私はモバイル版のChatGPTが大好きです。無料版でも音声認識機能があり、外出時に直接音声で質問できるので、とても便利です。

### 現状よく聞かれるモデルは何がある？

会社から分けます：

**OpenAI**：広く知られているLLMの先駆者企業。

- GPT3.5：前世代のモデル。ウェブアプリケーションChatGPTはこのモデルに基づいています。
- GPT4：最新のモデル。有料会員になると、ChatGPTウェブアプリケーションでこのモデルを選択したり、APIを使用したり、モデルのファインチューニングをコントロールパネルで行ったり（つまり、手元のデータを使用してモデルを自分のニーズにより適応させること）して、独自のAIアシスタントを作成できます。仕事が非常に反復的な場合、このアシスタントを使用して作業を自動化し、仕事を楽にこなすことができます。
- DALLE：有料モデル。コントロールパネルでこのモデルを選択し、画像を生成したり、生成的アルゴリズムGAN（このアルゴリズムがモデルに絵を描かせることを教えることができると理解すればよい）の成果モデルを取得したりできます。
- Embeddings：テキストを数字に変換するツール。自分でモデルの微調整を行いたい人向けのものです。なぜなら、モデルにデータを提供するためには、あなたのテキストを数字に変換する必要があるからです。つまり、これはモデルの準備に使用されるツールです。

可能であればGPT4使うのベスト選択です。

**Anthropic**：この会社は非常に興味深いです。創業者はOpenAIから出てきましたが、OpenAIのアプローチに不満を持ち、モデルの扱いが適当で安全でないと感じたため、独自の会社を立ち上げました。彼らのモデルは現在非常に人気があります！

- Claude3：彼らの最新のモデルです。このモデルを使用したウェブアプリケーションはClaudeと呼ばれています。テキストを生成したり、画像をアップロードして画像に関するトークを生成したりできます。私はこのウェブアプリケーションを使用していますが、賢く感じます。Pro版を購入していないため、APIやバックエンドの状況はわかりません。一日の質問数も制限があります。学習のパートナーとして使用したいが、有料は避けたいという場合、Claudeは良い選択肢です。

**Google**：

- Gimini：ウェブアプリケーションは非常に使いやすく、精度も良いです。時々馬鹿馬鹿しく感じるが、私のプロンプト方法がまだよくないかも。

何かを調べる場合、Claudeと組み合わせると十分です。また、GoogleMapなどの複数のアプリケーションが統合されており、まるでGoogleの多くのアプリケーションにツールが追加されたかのように自然です。APIは無料アカウントで1日50回の試用が可能で、以前にGiminiのAPIの使用方法を学習しましたが、その日の制限を使い切っていませんでした。

Giminiの好きなところは、コンテンツの出典を教えてくれることです。これにより、さらに調査を行うことができます。

**Meta**：

- Llama3：オープンソースで最新で最強のモデルであり、GPT4よりも優れていますと一時聞いたことがあり。

ウェブサイトは[こちら](https://lmstudio.ai/)にあります。自分のマシンがこのモデルを実行できるかどうかをチェックし、OKならモデルをダウンロードしてローカルで使用できます。

これがそのparametersファイルですが、本当にparametersと呼ばれ、サイズは140GBです。それから、ローカルでモデルを実行できるようになります。完全にオフラインで動作し、とてもCoolです。

**Microsoft**：

- BingにもGPT4が組み込まれています。しかし、自分はあまり使用しないため、ここでは説明遠慮します。興味あれば試してみてください。内部ではGPTが使用されていることだけを知っておけば十分です。

まとめると、これらのモデルはすべてTransformerアルゴリズムに基づいており、その性能は各社の計算能力とデータに依存しています。

### LLMをどのように見るか

- 学習パートナー：クエリツール、記事要約ツール、迅速な回答を得るためのツール。しかし、ただのアドバイザーに過ぎません。提案や結果を確認してから使用してくださいが、彼の提案は採用されやすいです。

- LLMの情報はこの世界の正規分布の結果の反映です：例えば、サイコロを振ったら何が出るか尋ねると、4が出ると言うでしょう。なぜなら、それが統計的結果だからです。人々はテキストで4を言いがちです、多分ですが、統計の力が支配しています。

- 表現が苦手な博識者：質問が詳細であればあるほど、回答はより良くなります。あなたの考え方がより論理的であれば、質問を導ければ導くほど、正しい結果を得ることができます。あなたはまるで大学院生の指導教授であり、知識の宝庫を引き出すことがあなたの任務です。

例えば、ゲームコードを書く必要があるとします。直接彼に書かせるよりも、まず彼にコーディングプロセスを出力させ、それからそのプロセスに従ってコーディングする方がずっと良いでしょう。

これにより、彼は自分の出力を入力として使用して作業を続けることができます。

- ただのツール：多くの人がAIに自分の仕事を置き換えられるのを恐れていますが、自分自身を置き換えられるのはAIツールを使える人だけです。AIそのものではありません。単なるツールに過ぎません。内部原理にこだわらず、単に使用する場合、それほど難しいことはありません。重要なのは、自分の考え方の論理性と、ツールを使用して学習効率を向上させることです。

### 簡単説明のまとめ

モデルを簡潔にまとめると：計算リソースとデータを使用し、一連のランダムなパラメータを繰り返しトレーニングして、データ予測可能な、パラメータを得ることでモデル作れます。これらのモデルのパラメータを使用して、入力を処理し、出力を得ます。エンジニアは、トレーニング後の部分に焦点を当てるだけで良いです。

この分野は非常に広大であり、このような説明は非常に粗雑ですが、モデルを使用し、実際のシステムに組み込むことを目指すエンジニアにとっては、まずその本質を理解することが、多くの問題を単純化するのに役立ちます。

### LLMと他の大型モデルがもたらす技術プロセスの変革

モデル内部の原理を研究するのはアルゴリズムエンジニアですが、ソフトウェアエンジニア、システムエンジンニアは新しい環境をどのように受け入れ、統合する必要がありますか？

ここで、この問題に答えたいと思います。

自分も色々調べましたが、その中には一部の意見が一時的に受け入れられると感じるものがあります。たとえば、以下の比較的快適なルートがあります：

プロンプトエンジニアリング → APIの呼び出し → AIアプリケーション開発フレームワーク → RAG技術 → エージェント → モデルのファンチューニング関連 → モデルの実装と提供

将来、関連するプロジェクトの構築が必要な場合、この理解が良い出発点になるかもしれません。少なくとも、私が現状見たプロジェクトはこの範囲を超えていません。新しいもの期待できるでしょう。

以下では、それぞれを簡単に紹介し、高いレベルで理解します。開発に必要な場合は、概念を調べることで、それがどこに位置しているかがわかります。

**1. プロンプトエンジニアリング**：

LLMの使用に基づいて、大規模モデルの能力を引き出すための質問方法を研究します。人間の言葉で質問するだけですが、LLMには明確なプロセスと手法があります。

正しい質問にはより正確な回答が得られます。Langchainのライブラリ内の「System Message」や「Human Message」は、原理に基づいています。これらの要素を追加する必要があることはわかっていますが、なぜそれを追加する必要があるのかを理解していない方も多いだろう。

プロンプトエンジニアリングの各要素は、内部原理に対応して適切に設定されています。生活や開発の中で注目すべき部分です。

プログラミングはコンピューター向けの言語ですが、人間の言語はLLMモデルのプログラミング言語です。

**2. APIの呼び出し**：

これはすべてのエンジニアやプログラマーに必要なスキルです。APIを使用するか、またはフレームワークを使用して基本モデルを呼び出し、プロンプトエンジニアリングとシステム構築を行います。

**3. AIアプリケーション開発フレームワーク**：

現在のLLMのアプリケーションは、 AIGC（コンテンツ生成）、Insight（知識洞察）、Copilot（スマートアシスタント）、Agent（デジタルエージェント）の4つの段階で進化しています。

異なるアプリケーションを構築する際には、さまざまな開発フレームワークやツールに触れることになります。最も広く知られているのはLangChainです。これらの新しいフレームワークやツールはまだ開発中であり、プログラマーや開発者は迅速に学習し、適応する能力が必要です。

しかし、一度理解すれば、他のものも同じです。原理を理解した後、新しいものに取り組むと不慣れに感じることはないでしょう。

**4. RAG技術**：

LLMモデル自体の知識が専門的で垂直でない場合、RAG（Retrieval-Augmented Generation）技術を使用して外部知識ベースを導入して、モデルの生成能力を強化することができます。

RAGは検索と生成を意味し、モデルに検索コンテンツを提供し、モデル自身の出力の部分を使用して、より一貫した生成結果を得るタスクです。

企業内の情報検索や結果生成プロジェクトに適しています。

**5. エージェント**：

大規模モデル領域の「自動化」。 "感知"、 "記憶"、 "計画"などのメカニズムを組み込むことで、LLMが自己思考（本物の思考じゃない）、意思、決定、計画、実行を行い、問題を解決します。

ここのキーワードは自動化です。そのため、LangChainフレームワークの「Agent Tool」モジュールを使用すると、コードは非常に少なく、非常にシンプルで強力になります。なぜなら、モデルは問題を自律的に解決しているからです。

**6. モデルのファンチューニング**：

この段階からは、やや専門的な話になります。通常、エージェントが理解できれば、開発者のアーキテクチャの理解が十分です。

ただし、この部分の完全性のために、簡単に説明します。

ファンチューニングは、既存の事前トレーニング済みモデルを特定のタスクに対して局所的に調整することです。もっとも近い例では、GPTモデルをChatGPTロボットにファンチューニングすることです。

ファンチューニングの領域にはさまざまな方法がありますが、この記事の複雑さを増やす必要はないため省略します。

**7. モデルの製品展開と提供**：

一般的な展開プラットフォームやツールについて理解し、プライベートデプロイメントのハードウェア選択について理解し、モデルのパッケージ化、テスト、展開方法を学びます。

私は実際には行ったことがないので詳細はわかりませんが、私が知っている知識からは、AWSのAutoML、DatabricksのAutoMLなど、モデルの自動デプロイなどのプラットフォームがあります。

デプロイメントは、モデルをエッジリージョンに展開することで、推理を早くなるなど、さまざまな技術があります。

モデルのパッケージ化、テスト、リリースなど、よりエンジニアリングに近い部分はまだに実践したことなく、私自身も学習中です。

### 最後に

AI時代に、だれでも新しい変革から、新しい可能性を生み出すことを祈ってます。

世界で唯一わからないことは「変わる」ことです。その中で日々進化しよう。
