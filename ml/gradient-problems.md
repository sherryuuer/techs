## 梯度消失和梯度爆炸问题

---

### 什么是梯度

很多地方你问别人问题，别人给你的答案你看不懂，一般是因为前置知识不清楚。所以有问题就深挖问题。不断问为什么，递归地解决它。

那么从什么是梯度开始。梯度是函数的梯度，是一种坡度，角度，在机器学习中，梯度是损失函数的梯度。

想象一个损失函数的曲线，让他的梯度也就是斜率降低到最小，就可以到达这个函数的最低点，我们在机器学习中的目的就是损失函数的最小化。所以相同的就是让梯度不断下降。因为在最低点的梯度为0。

### 什么是梯度消失和梯度爆炸

**梯度消失**的原因是权重更新过小。比如在深度神经网络反向传播的过程中，或者使用了sigmoid，或者tanh激活函数的时候，每次都会更新权重。根据链式法则，因为导数的计算，需要多层的导数不断相乘，层数很深就会越乘越小。最终导致了梯度的消失。

原因：比如因为激活函数，比如刚刚说的sigmoid和tanh，在输入较大或者较小的时候，导数很小。或者初始化权重的时候，有时候随机初始的权重太小。

应对方法：合适的激活函数比如ReLU。批标准化提高稳定性。残差连接。

残差连接是一种神经网络中的构架技巧，可以简化网络的训练。传统的网络训练过程是一层一层前向传播的，将前一层的输出加入到后一层的输入中，残差则可以跨层进行这一过程，将前一层的输出加入到下下一层，类似这样。它的好处在与，当一层学到一个近似于0的变换的时候，可以跳过这一层，直接进入下一层，从而降低梯度消失的风险。

和梯度消失相反的，就是**梯度爆炸**，是一种权重不断变的很大的问题，导致神经网络完全没法训练。

应对方法：合适的初始权重，合适的激活函数，正则化技术，梯度裁剪（gradient clipping）(设置一个阈值，如果梯度的绝对值超过这个阈值，就进行梯度缩放，使他小于阈值)

**LSTM也可以解决梯度问题！**

Long Short-Term Memory（LSTM）是一种特殊的循环神经网络（RNN）架构，设计用于解决梯度消失问题。LSTM引入了一种称为“门”的机制，它能够选择性地遗忘或存储信息，从而更好地处理和传递梯度。这使得LSTM相对于普通的RNN更能够有效地捕捉和处理长期依赖关系，避免梯度在传播过程中消失或爆炸。

LSTM包括三个主要的门：遗忘门（Forget Gate）、输入门（Input Gate）、输出门（Output Gate）。这些门由一些权重和激活函数来控制，它们的存在使得LSTM能够在处理序列数据时更加灵活。

具体来说，LSTM中的遗忘门决定了在每个时间步上要遗忘多少先前的信息，输入门则决定了要存储多少新的信息。这种机制允许LSTM在处理长序列时选择性地保留和传递重要的信息，而不容易遭受梯度消失的问题。

总的来说，LSTM通过引入门控制机制，能够在学习和传播信息时更好地处理长期的依赖关系，有效地解决了梯度消失的问题。这使得LSTM在处理时序数据、自然语言处理等任务中表现得相对较好。由于其优越的性能，LSTM及其变体如Gated Recurrent Unit（GRU）已成为处理序列数据的主要工具之一。

### 为什么权重更新过小，梯度就会渐渐消失？

因为在深度学习的过程中，是通过不断反向传播调整权重来更新模型，从而使得损失函数的数值不断减小，而梯度，表示损失函数对于模型参数的变化率。也就是说，在参数空间中（想象是损失函数的坐标系图像），参数的变化对损失计算的影响，参数改变的时候损失函数的变化是如何的，梯度就是这个函数变化的方向，向着梯度的反方向不断下降，就可以不断优化函数，降低损失。

具体步骤有三个：

1， 计算梯度：对损失函数，关于模型参数的每个参数计算偏导，得到梯度向量。（如果忘记了什么是损失函数就先看下面的部分）

2， 更新权重：根据学习率的大小，将每个参数的梯度向量，沿着梯度的反方向进行微小调整。（学习率，就是你调整的步长，是调整快慢的问题）

3， 重复步骤一和二，直到达到满意的算法收敛。

### 继续提问损失函数是什么？

顺便把优化器也解释一下，因为在tensorflow和pytorch学习中，这两个东西经常一起定义。

损失函数：

损失函数是在机器学习或深度学习任务开始之前选择或定义的。损失函数是衡量模型在训练过程中预测输出与真实标签之间差异的指标。目标是通过调整模型的参数使损失函数最小化。

选择或定义损失函数的过程通常取决于任务的性质和模型的设计。不同的任务（如分类、回归、生成等）可能需要使用不同的损失函数。以下是一些常见的损失函数：

1. **均方误差（Mean Squared Error，MSE）：** 用于回归任务，计算模型输出与真实标签之间的平方差的平均值。

2. **交叉熵损失（Cross-Entropy Loss）：** 用于分类任务，特别是在使用 softmax 函数作为输出层激活函数的神经网络中。包括二分类交叉熵和多分类交叉熵。

3. **对数损失（Log Loss）：** 类似于交叉熵损失，常用于二分类任务。

4. **希望小的损失函数（Hinge Loss）：** 通常用于支持向量机（Support Vector Machines）等模型，主要用于二分类任务。

5. **自定义损失函数：** 针对特定任务，有时需要定义自己的损失函数，以便更好地符合任务的特性。

损失函数的选择直接影响到模型的训练效果。在模型训练的过程中，优化算法通过最小化损失函数来调整模型的参数，使其更好地适应训练数据并提高在未见过的数据上的泛化性能。因此，选择合适的损失函数是机器学习和深度学习中的一个重要决策。

优化器optimizer：

在机器学习和深度学习中，优化器（Optimizer）是用于最小化或最大化损失函数的算法。损失函数衡量了模型的预测输出与真实标签之间的差异。优化器的目标是通过调整模型的参数，使损失函数达到最小值或最大值。

优化器的工作原理是根据损失函数的梯度信息来更新模型的参数。梯度表示了损失函数关于模型参数的变化率，而优化器利用这些梯度信息来调整参数，使得损失函数逐渐减小。这个过程通常被称为梯度下降。

常见的优化器包括但不限于：

1. **随机梯度下降（Stochastic Gradient Descent，SGD）：** 在每个训练样本上计算梯度并更新参数，通常使用小批量样本（Mini-Batch SGD）以减少计算开销。

2. **动量优化器（Momentum）：** 在梯度更新时引入动量项，以在参数更新方向上积累动量，加速收敛。

3. **Adam：** 结合了动量和自适应学习率的方法，常用于深度学习任务。

4. **Adagrad：** 自适应学习率的方法，根据参数的历史梯度信息进行调整。

5. **RMSprop：** 与 Adagrad 类似，但通过指数加权移动平均来平滑历史梯度信息。

6. **Adadelta：** 类似于 RMSprop，但使用了更复杂的学习率调整机制。

7. **Nadam：** 结合了 Nesterov 动量和 Adam 的优点。

选择合适的优化器通常依赖于具体的任务和模型结构，因为不同的优化器在不同的情境下可能表现更好。深度学习框架（如TensorFlow、PyTorch等）通常提供了各种优化器的实现，用户可以根据需要选择合适的优化器。

动量的解释：
在优化算法中，动量（Momentum）是一种用于加速梯度下降过程的技术。它通过引入一个动量项，模拟物体在运动中的惯性，从而更有效地更新模型的参数。动量的主要目的是减缓参数更新的摆动，提高收敛速度，并减少在梯度方向上的震荡。反之我们经常会在dl中使用的是Adam！
